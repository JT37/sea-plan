### 字符串-前缀索引

`MySQL` 是支持前缀索引的，也就是说，你可以定义字符串的一部分作为索引。默认地，如果你创建索引的语句不指定前缀长度，那么索引就会包含整个字符串。

```
比如，这两个在 email 字段上创建索引的语句：
mysql> alter table SUser add index index1(email);
或
mysql> alter table SUser add index index2(email(6));

第一个语句创建的 index1 索引里面，包含了每个记录的整个字符串；

而第二个语句创建的 index2 索引里面，对于每个记录都是只取前 6 个字节。
```

由于 `email(6)` 这个索引结构中每个邮箱字段都只取前 `6` 个字节（即：`zhangs`），所以占用的空间会更小，这就是使用前缀索引的优势。

### 字符串前缀索引执行流程

```
select id,name,email from SUser where email='zhangssxyz@xxx.com';
```

#### 整字段索引

如果使用的是 `index1`（即 `email` 整个字符串的索引结构），执行顺序是这样的：
1. 从 `index1` 索引树找到满足索引值是’`zhangssxyz@xxx.com`’的这条记录，取得 `ID2` 的值；
2. 到主键上查到主键值是 `ID2` 的行，判断 `email` 的值是正确的，将这行记录加入结果集；
3. 取 `index1` 索引树上刚刚查到的位置的下一条记录，发现已经不满足 `email='zhangssxyz@xxx.com’` 的条件了，循环结束。

这个过程中，只需要回主键索引取一次数据，所以系统认为只扫描了一行。

#### 字段前缀索引

如果使用的是 `index2`（即 `email(6)` 索引结构），执行顺序是这样的：

1. 从 `index2` 索引树找到满足索引值是`zhangs`的记录，找到的第一个是 `ID1`；
2. 到主键上查到主键值是 `ID1` 的行，判断出 `email` 的值不是’`zhangssxyz@xxx.com`’，这行记录丢弃；
3. 取 `index2` 上刚刚查到的位置的下一条记录，发现仍然是’`zhangs`’，取出 `ID2`，再到 `ID` 索引上取整行然后判断，这次值对了，将这行记录加入结果集；
4. 重复上一步，直到在 `index2` 上取到的值不是’`zhangs`’时，循环结束。

在这个过程中，要回主键索引取 `4` 次数据，也就是扫描了 `4` 行。

通过这个对比，很容易就可以发现，使用前缀索引后，`可能会导致查询语句读数据的次数变多`。

但是，对于这个查询语句来说，如果你定义的 `index2` 不是 `email(6)` 而是 `email(7）`，也就是说取 `email` 字段的前 `7` 个字节来构建索引的话，即满足前缀’`zhangss`’的记录只有一个，也能够直接查到 `ID2`，只扫描一行就结束了。

也就是说使用前缀索引，`定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本`。

#### 如何确定应该使用多长的前缀呢？

实际上，我们在建立索引时关注的是区分度，区分度越高越好。因为区分度越高，意味着重复的键值越少。因此，我们可以通过统计索引上有多少个不同的值来判断要使用多长的前缀。

```
首先，你可以使用下面这个语句，算出这个列上有多少个不同的值：

mysql> select count(distinct email) as L from SUser;

然后，依次选取不同长度的前缀来看这个值，比如我们要看一下 4~7 个字节的前缀索引，可以用这个语句：

mysql> select 
  count(distinct left(email,4)）as L4,
  count(distinct left(email,5)）as L5,
  count(distinct left(email,6)）as L6,
  count(distinct left(email,7)）as L7,
from SUser;
```

当然，使用前缀索引很可能会损失区分度，所以你需要预先设定一个可以接受的损失比例，比如 `5%`。然后，在返回的 `L4~L7` 中，找出不小于 `L * 95%` 的值，假设这里 `L6、L7` 都满足，你就可以选择前缀长度为 `6`。


#### 前缀索引对覆盖索引的影响

使用前缀索引可能会增加扫描行数，这会影响到性能。其实还会影响到覆盖索引。

```

select id,email from SUser where email='zhangssxyz@xxx.com';


select id,name,email from SUser where email='zhangssxyz@xxx.com';
```

如果语句只要求返回 `id` 和 `email` 字段。

如果使用 `index1`（即 `email` 整个字符串的索引结构）的话，可以利用覆盖索引，从 `index1` 查到结果后直接就返回了，不需要回到 `ID` 索引再去查一次。

而如果使用 `index2`（即 `email(6)` 索引结构）的话，就不得不回到 `ID` 索引再去判断 `email` 字段的值。即使你将 `index2` 的定义修改为 `email(18)` 的前缀索引，这时候虽然 `index2` 已经包含了所有的信息，但 `InnoDB` 还是要回到 `id` 索引再查一下，因为系统并不确定前缀索引的定义是否截断了完整信息。

也就是说，`使用前缀索引就用不上覆盖索引对查询性能的优化了`，这也是你在选择是否使用前缀索引时需要考虑的一个因素。

### 倒序存储再创建前缀索引

如果你存储身份证号的时候把它倒过来存，每次查询的时候，你可以这么写：
```
mysql> select field_list from t where id_card = reverse('input_id_card_string');
```

由于身份证号的最后 `6` 位没有地址码这样的重复逻辑，所以最后这 `6` 位很可能就提供了足够的区分度。

### 使用 hash 字段

可以在表上再创建一个整数字段，来保存身份证的校验码，同时在这个字段上创建索引。

```
mysql> alter table t add id_card_crc int unsigned, add index(id_card_crc);

然后每次插入新记录的时候，都同时用 crc32() 这个函数得到校验码填到这个新字段。由于校验码可能存在冲突，也就是说两个不同的身份证号通过 crc32() 函数得到的结果可能是相同的，所以你的查询语句 where 部分要判断 id_card 的值是否精确相同。

mysql> select field_list from t where id_card_crc=crc32('input_id_card_string') and id_card='input_id_card_string'
```

这样，索引的长度变成了 `4` 个字节，比原来小了很多。

### 字符串字段创建索引的场景
- 直接创建完整索引，这样可能比较占用空间；
- 创建前缀索引，节省空间，但会增加查询扫描次数，并且不能使用覆盖索引；
- 倒序存储，再创建前缀索引，用于绕过字符串本身前缀的区分度不够的问题；
- 创建 `hash` 字段索引，查询性能稳定，有额外的存储和计算消耗，跟倒序方式一样，都不支持范围扫描。

在实际应用中，要根据业务字段的特点选择使用哪种方式。