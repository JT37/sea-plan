### 优化器的逻辑

优化器选择索引的目的，是找到一个最优的执行方案，并用最小的代价去执行语句。在数据库里面，扫描行数是影响执行代价的因素之一。扫描的行数越少，意味着访问磁盘数据的次数越少，消耗的 `CPU` 资源越少。

当然，扫描行数并不是唯一的判断标准，优化器还会结合是否使用临时表、是否排序等因素进行综合判断。

#### 扫描行数是怎么判断的？

`MySQL` 在真正开始执行语句之前，并不能精确地知道满足这个条件的记录有多少条，而只能根据统计信息来估算记录数。

这个统计信息就是索引的“区分度”。显然，一个索引上不同的值越多，这个索引的区分度就越好。而一个索引上不同的值的个数，我们称之为“基数”（`cardinality`）。也就是说，这个基数越大，索引的区分度越好。

执行命令：`show index from table;` 查看一个索引的基数，但是并不准确。

#### MySQL 是怎样得到索引的基数的呢？

`MySQL` 采样统计，因为把整张表取出来一行行统计，虽然可以得到精确的结果，但是代价太高了，所以只能选择“采样统计”。

采样统计的时候，`InnoDB` 默认会选择 `N` 个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数。

而数据表是会持续更新的，索引统计信息也不会固定不变。所以，当变更的数据行数超过 `1/M `的时候，会自动触发重新做一次索引统计。

在 `MySQL` 中，有两种存储索引统计的方式，可以通过设置参数 `innodb_stats_persistent` 的值来选择：
- 设置为 `on` 的时候，表示统计信息会持久化存储。这时，默认的 `N` 是 `20`，`M` 是 `10`。
- 设置为 `off` 的时候，表示统计信息只存储在内存中。这时，默认的 `N` 是 `8`，`s` 是 `16`。

由于是采样统计，所以不管 `N` 是 `20` 还是 `8`，这个基数都是很容易不准的。

优化器有时会选择扫描行数更多的索引，因为可能是普通索引扫描行数少，但是需要回表，所以它认为直接扫描主键索引更快。

`MySQL` 选错索引，这件事儿还得归咎到没能准确地判断出扫描行数。

执行 `analyze table t` 命令，可以用来重新统计索引信息。在实践中，如果你发现 `explain` 的结果预估的 `rows` 值跟实际情况差距比较大，可以采用这个方法来处理。

如果只是索引统计不准确，通过 `analyze` 命令可以解决很多问题，但是优化器可不止是看扫描行数。

#### 索引选择异常和处理

其实大多数时候优化器都能找到正确的索引，但偶尔你还是会碰到我们上面举例的这两种情况：原本可以执行得很快的 `SQL` 语句，执行速度却比你预期的慢很多，应该怎么办呢？

一种方法是，采用 `force index` 强行选择一个索引。`MySQL` 会根据词法解析的结果分析出可能可以使用的索引作为候选项，然后在候选列表中依次判断每个索引需要扫描多少行。如果 `force index` 指定的索引在候选索引列表中，就直接选择这个索引，不再评估其他索引的执行代价。

优化器没有选择正确的索引，`force index` 起到了“矫正”的作用。

程序员不喜欢使用 `force index`，一来这么写不优美，二来如果索引改了名字，这个语句也得改，显得很麻烦。而且如果以后迁移到别的数据库的话，这个语法还可能会不兼容。

第二种方法就是，我们可以考虑修改语句，引导 `MySQL` 使用期望的索引。

```
比如，然把“order by b limit 1” 改成 “order by b,a limit 1” ，语义的逻辑是相同的。

b 扫描行数多于 a 的情况

现在 order by b,a 这种写法，要求按照 b,a 排序，就意味着使用这两个索引都需要排序。因此，扫描行数成了影响决策的主要条件，于是此时优化器选了只需要扫描 1000 行的索引 a。
```

第三种方法是，在有些场景下，可以新建一个更合适的索引，来提供给优化器做选择，或删掉误用的索引。

新增索引，改变优化器行为，情况比较少。

删掉索引，发现这个优化器错误选择的索引其实根本没有必要存在，于是就删掉了这个索引，优化器也就重新选择到了正确的索引。