### Redis 常见的四种统计模式
- 聚合统计
- 排序统计
- 二值状态统计
- 基数统计

#### 聚合统计

场景：统计新增用户数和留存用户数

所谓的聚合统计，就是指统计多个集合元素的聚合结果，包括：统计多个集合的共有元素（交集统计）；把两个集合相比，统计其中一个集合独有的元素（差集统计）；统计多个集合的所有元素（并集统计）。

```
SET 并集
SUNIONSTORE  user:id  user:id  user:id:20200803 

SET 差集
SDIFFSTORE  user:new  user:id:20200804 user:id  

SET 交集
SINTERSTORE user:id:rem user:id:20200803 user:id:20200804

Set 的差集、并集和交集的计算复杂度较高，在数据量较大的情况下，如果直接执行这些计算，会导致 Redis 实例阻塞。
小建议：可以从主从集群中选择一个从库，让它专门负责聚合计算，或者是把数据读取到客户端，在客户端来完成聚合统计，这样就可以规避阻塞主库实例和其他从库实例的风险了。
```

#### 排序统计

场景：最新评论列表

集合中的元素可以按序排列，这种对元素保序的集合类型叫作有序集合。

在 `Redis` 常用的 `4` 个集合类型中（`List、Hash、Set、Sorted Set`），`List` 和 `Sorted Set` 就属于有序集合。

`List` 是按照元素进入 `List` 的顺序进行排序的，而 `Sorted Set` 可以根据元素的权重来排序。

`List` 使用的插入的位置来获取排序，`Sorted Set` 根据元素的实际权重来排序和获取数据的。在面对需要展示最新列表、排行榜等场景时，如果数据更新频繁或者需要分页显示，建议你优先考虑使用 `Sorted Set`。

```
// 获取 product1 这个列表 3 到 5 位置的数据，如果此时发生插入或减少新数据，一旦分页获取数据就会有问题
LRANGE product1 3 5

// 假设有序集合 comments，越新的评论权重越大，目前最新评论的权重是 N，我们执行下面的命令时，就可以获得最新的 10 条评论：
ZRANGEBYSCORE comments N-9 N
```

#### 二值状态统计

场景：用户签到数

二值状态统计：这里的二值状态就是指集合元素的取值就只有 `0` 和 `1` 两种。在签到打卡的场景中，只用记录 `签到（1）或未签到（0）`，所以它就是非常典型的二值状态。

在签到统计时，每个用户一天的签到用 `1` 个 `bit` 位就能表示，一个月（假设是 `31` 天）的签到情况用 `31` 个 `bit` 位就可以，而一年的签到也只需要用 `365` 个 `bit` 位，根本不用太复杂的集合类型。这个时候，就可以选择 `Redis` 提供的扩展数据类型 `Bitmap`。

`Bitmap` 本身是用 `String` 类型作为底层数据结构实现的一种统计二值状态的数据类型。`String` 类型是会保存为二进制的字节数组，所以，`Redis` 就把字节数组的每个 `bit` 位利用起来，用来表示一个元素的二值状态。可以把 `Bitmap` 看作是一个 `bit` 数组。

`Bitmap` 提供了 `GETBIT/SETBIT` 操作，使用一个偏移值 `offset` 对 `bit` 数组的某一个 `bit` 位进行读和写。不过，需要注意的是，`Bitmap` 的偏移量是从 `0` 开始算的，也就是说 `offset` 的最小值是 `0`。当使用 `SETBIT` 对一个 `bit` 位进行写操作时，这个 `bit` 位会被设置为 `1`。`Bitmap` 还提供了 `BITCOUNT` 操作，用来统计这个 `bit` 数组中所有 `1` 的个数。

```
假设要统计 ID 3000 的用户在 2020 年 8 月份的签到情况，就可以按照下面的步骤进行操作。

// 第一步，执行下面的命令，记录该用户 8 月 3 号已签到。
SETBIT uid:sign:3000:202008 2 1 

// 第二步，检查该用户 8 月 3 日是否签到。
GETBIT uid:sign:3000:202008 2 

// 第三步，统计该用户在 8 月份的签到次数。
BITCOUNT uid:sign:3000:202008

// Bitmap 支持用 BITOP 命令对多个 Bitmap 按位做“与”“或”“异或”的操作，操作的结果会保存到一个新的 Bitmap 中。
// 三个 key 与操作，结果保存到一个 bitmap key 中
BITOP AND newANDkeyName key1 key2 key3

计算一下记录了 10 天签到情况后的内存开销。
每天使用 1 个 1 亿位的 Bitmap，大约占 12MB 的内存（10^8/8/1024/1024），10 天的 Bitmap 的内存开销约为 120MB，内存压力不算太大。不过，在实际应用时，最好对 Bitmap 设置过期时间，让 Redis 自动删除不再需要的签到记录，以节省内存开销。
```

#### 基数统计

场景：网页独立访客量

基数统计就是指统计一个集合中不重复的元素个数。对应到我们刚才介绍的场景中，就是统计网页的 `UV`。

网页 `UV` 的统计有个独特的地方，就是需要去重，一个用户一天内的多次访问只能算作一次。在 `Redis` 的集合类型中，`Set` 类型默认支持去重，当看到有去重需求时，我们可能第一时间就会想到用 `Set` 类型。当然，`Hash` 类型也可以记录 `UV`。

当页面很多时，`Set` 和 `Hash` 类型会消耗很大的内存空间。

`HyperLogLog` 是一种用于统计基数的数据集合类型，它的最大优势就在于，当集合元素数量非常多时，它计算基数所需的空间总是固定的，而且还很小。

在 `Redis` 中，每个 `HyperLogLog` 只需要花费 `12 KB` 内存，就可以计算接近 `2^64` 个元素的基数。和元素越多就越耗费内存的 `Set` 和 `Hash` 类型相比，`HyperLogLog` 就非常节省空间。

```
在统计 UV 时，你可以用 PFADD 命令（用于向 HyperLogLog 中添加新元素）把访问页面的每个用户都添加到 HyperLogLog 中。
PFADD page1:uv user1 user2 user3 user4 user5

接下来，就可以用 PFCOUNT 命令直接获得 page1 的 UV 值了，这个命令的作用就是返回 HyperLogLog 的统计结果。
PFCOUNT page1:uv

```
需要注意一下，`HyperLogLog` 的统计规则是基于概率完成的，所以它给出的统计结果是有一定误差的，标准误算率是 `0.81%`。这也就意味着，你使用 `HyperLogLog` 统计的 `UV` 是 `100` 万，但实际的 `UV` 可能是 `101` 万。虽然误差率不算大，但是，如果需要精确统计结果的话，最好还是继续用 `Set` 或 `Hash` 类型。

对于基数统计来说，如果集合元素量达到亿级别而且不需要精确统计时，建议使用 `HyperLogLog`。

HyperLogLog 如何实现： https://en.wikipedia.org/wiki/HyperLogLog 

#### 统计模式差异对比
![集合统计类型对比图](../../Picture/集合统计类型对比图.jpeg)

