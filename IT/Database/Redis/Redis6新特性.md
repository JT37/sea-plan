### Redis 6.0 

`Redis 6.0` 中的几个关键新特性，分别是`面向网络处理的多 IO 线程`、`客户端缓存`、`细粒度的权限控制`，以及 `RESP 3 协议的使用`。

其中，面向网络处理的多 `IO` 线程可以提高网络请求处理的速度，而客户端缓存可以让应用直接在客户端本地读取数据，这两个特性可以提升 `Redis` 的性能。除此之外，细粒度权限控制让 `Redis` 可以按照命令粒度控制不同用户的访问权限，加强了 `Redis` 的安全保护。`RESP 3` 协议则增强客户端的功能，可以让应用更加方便地使用 `Redis` 的不同数据类型。

#### 从单线程处理网络请求到多线程处理

在 `Redis 6.0` 中，非常受关注的第一个新特性就是多线程。这是因为，`Redis` 一直被大家熟知的就是它的单线程架构，虽然有些命令操作可以用后台线程或子进程执行（比如数据删除、快照生成、`AOF` 重写），但是，从网络 `IO` 处理到实际的读写命令处理，都是由单个线程完成的。

随着网络硬件的性能提升，`Redis` 的性能瓶颈有时会出现在网络 `IO` 的处理上，也就是说，单个主线程处理网络请求的速度跟不上底层网络硬件的速度。

`Redis 6.0` 采用多个 `IO` 线程来处理网络请求，提高网络请求处理的并行度。

`Redis` 的多 `IO` 线程只是用来处理网络请求的，对于读写命令，`Redis` 仍然使用单线程来处理。这是因为，`Redis` 处理请求时，网络处理经常是瓶颈，通过多个 `IO` 线程并行处理网络操作，可以提升实例的整体处理性能。而继续使用单线程执行命令操作，就不用为了保证 `Lua` 脚本、事务的原子性，额外开发多线程互斥机制了。这样一来，`Redis` 线程模型实现就简单了。

主线程和多 `IO` 线程的协作分成四个阶段。

##### 阶段一：服务端和客户端建立 Socket 连接，并分配处理线程

首先，主线程负责接收建立连接请求。当有客户端请求和实例建立 `Socket` 连接时，主线程会创建和客户端的连接，并把 `Socket` 放入全局等待队列中。紧接着，主线程通过轮询方法把 `Socket` 连接分配给 `IO` 线程。


##### 阶段二：IO 线程读取并解析请求

主线程一旦把 `Socket` 分配给 `IO` 线程，就会进入阻塞状态，等待 `IO` 线程完成客户端请求读取和解析。因为有多个 `IO` 线程在并行处理，所以，这个过程很快就可以完成。

##### 阶段三：主线程执行请求操作

等到 `IO` 线程解析完请求，主线程还是会以单线程的方式执行这些命令操作。

![redis主线程执行请求操作](../../Picture/redis主线程执行请求操作.webp)

##### 阶段四：IO 线程回写 Socket 和主线程清空全局队列

当主线程执行完请求操作后，会把需要返回的结果写入缓冲区，然后，主线程会阻塞等待 `IO` 线程把这些结果回写到 `Socket` 中，并返回给客户端。

和 `IO` 线程读取和解析请求一样，`IO` 线程回写 `Socket` 时，也是有多个线程在并发执行，所以回写 `Socket` 的速度也很快。等到 `IO` 线程回写 `Socket` 完毕，主线程会清空全局队列，等待客户端的后续请求。


![RedisIO线程回写Socket和主线程清空全局队列](../../Picture/RedisIO线程回写Socket和主线程清空全局队列.webp)


在 `Redis 6.0` 中，多线程机制默认是关闭的，如果需要使用多线程功能，需要在 `redis.conf` 中完成两个设置。

```
1. 设置 io-thread-do-reads 配置项为 yes，表示启用多线程。
    io-threads-do-reads yes

2. 设置线程个数。一般来说，线程个数要小于 Redis 实例所在机器的 CPU 核个数，例如，对于一个 8 核的机器来说，Redis 官方建议配置 6 个 IO 线程。
    io-threads  6
```

如果你在实际应用中，发现 `Redis` 实例的 `CPU` 开销不大，吞吐量却没有提升，可以考虑使用 `Redis 6.0` 的多线程机制，加速网络处理，进而提升实例的吞吐量。