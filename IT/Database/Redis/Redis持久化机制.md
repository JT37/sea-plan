`Redis` 的持久化主要有两大机制，即 `AOF(Append Only File)`日志和 `RDB(Redis Database)` 快照。

## AOF 日志

### 数据库日志 vs AOF 日志
- 数据库的写前日志（`Write Ahead Log, WAL`），也就是说，在实际写数据前，先把修改的数据记到日志文件中，以便故障时进行恢复。

- `AOF` 日志与数据库日志正好相反，它是写后日志，`“写后”`的意思是 `Redis` 是先执行命令，把数据写入内存，然后才记录日志。

![Redis的AOF操作过程](../../Picture/Redis的AOF操作过程.jpeg)

传统数据库的日志，例如 `redo log（重做日志）`，记录的是修改后的数据，而 `AOF` 里记录的是 `Redis` 收到的每一条命令，这些命令是以文本形式保存的。


### Redis 收到命令后记录日志流程

例：Redis 收到“set testkey testvalue”命令后记录的日志，如图
![Redis的AOF日志内容](../../Picture/Redis的AOF日志内容.jpeg)
`*3` 表示当前命令有三个部分，每部分都是由 `$+数字` 开头，后面紧跟着具体的命令、键或值。这里，`数字` 表示这部分中的命令、键或值一共有多少字节。例如，`$3 set` 表示这部分有 `3` 个字节，也就是 `set` 命令。

为了避免额外的检查开销，`Redis` 在向 `AOF` 里面记录日志的时候，并不会先去对这些命令进行语法检查。

只有命令能执行成功，才会被记录到日志中，`Redis` 使用写后日志这一方式的一大好处是，可以避免出现记录错误命令的情况。

在命令执行后才记录日志，所以不会阻塞当前的写操作。

### AOF 潜在风险

- 如果刚执行完一个命令，还没有来得及记日志就宕机了，那么这个命令和相应的数据就有丢失的风险。如果把 `Redis` 当作数据库使用，因为命令没有记入日志，所以就无法用日志进行恢复了。
- `AOF` 虽然避免了对当前命令的阻塞，但可能会给下一个操作带来阻塞风险。`AOF` 日志是在主线程中执行的，如果在把日志文件写入磁盘时，磁盘写压力大，就会导致写盘很慢，进而导致后续的操作也无法执行了。

### AOF 为避免潜在风险，提供三种写回策略

`AOF` 配置项 `appendfsync` 的三个可选值：
- `Always`，同步写回：每个写命令执行完，立马同步地将日志写回磁盘；
- `Everysec`，每秒写回：每个写命令执行完，只是先把日志写到 `AOF` 文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘；
- `No`，操作系统控制的写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。

针对避免主线程阻塞和减少数据丢失问题，这三种写回策略都无法做到两全其美。
- `同步写回` 可以做到基本不丢数据，但是它在每一个写命令后都有一个慢速的落盘操作，不可避免地会影响主线程性能；
- 虽然 `操作系统控制的写回` 在写完缓冲区后，就可以继续执行后续的命令，但是落盘的时机已经不在 Redis 手中了，只要 AOF 记录没有写回磁盘，一旦宕机对应的数据就丢失了；
- `每秒写回` 采用一秒写回一次的频率，避免了 `同步写回` 的性能开销，虽然减少了对系统性能的影响，但是如果发生宕机，上一秒内未落盘的命令操作仍然会丢失。所以，这只能算是，在避免影响主线程性能和避免数据丢失两者间取了个折中。
  
![AOF写回策略对比](../../Picture/AOF写回策略对比.jpeg)

总结一下就是：想要获得高性能，就选择 `No` 策略；如果想要得到高可靠性保证，就选择 `Always` 策略；如果允许数据有一点丢失，又希望性能别受太大影响的话，那么就选择 `Everysec` 策略。

### AOF 重写机制