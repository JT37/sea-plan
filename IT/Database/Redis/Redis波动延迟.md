#### Redis 变慢了, 如何判断 `Redis` 是不是真的变慢了

一个最直接的方法，就是查看 `Redis` 的响应延迟。

大部分时候，`Redis` 延迟很低，但是在某些时刻，有些 `Redis` 实例会出现很高的响应延迟，甚至能达到几秒到十几秒，不过持续时间不长，这也叫延迟“毛刺”。当发现 `Redis` 命令的执行时间突然就增长到了几秒，基本就可以认定 `Redis` 变慢了。

第二个方法，基于当前环境下的 `Redis` 基线性能做判断。所谓的基线性能呢，也就是一个系统在低压力、无干扰下的基本性能，这个性能只由当前的软硬件配置决定。

从 `2.8.7` 版本开始，`redis-cli` 命令提供了 `–intrinsic-latency` 选项，可以用来监测和统计测试期间内的最大延迟，这个延迟可以作为 `Redis` 的基线性能。其中，测试时长可以用 `–intrinsic-latency` 选项的参数来指定。
```
举个例子，比如说，我们运行下面的命令，该命令会打印 120 秒内监测到的最大延迟。可以看到，这里的最大延迟是 119 微秒，也就是基线性能为 119 微秒。一般情况下，运行 120 秒就足够监测到最大延迟了，所以，我们可以把参数设置为 120。

./redis-cli --intrinsic-latency 120
Max latency so far: 17 microseconds.
Max latency so far: 44 microseconds.
Max latency so far: 94 microseconds.
Max latency so far: 110 microseconds.
Max latency so far: 119 microseconds.

36481658 total runs (avg latency: 3.2893 microseconds / 3289.32 nanoseconds per run).
Worst run took 36x longer than the average latency.
```

需要注意的是，基线性能和当前的操作系统、硬件配置相关。

一般来说，你要把运行时延迟和基线性能进行对比，如果你观察到的 `Redis` 运行时延迟是其基线性能的 `2` 倍及以上，就可以认定 `Redis` 变慢了。

如果你想了解网络对 `Redis` 性能的影响，一个简单的方法是用 · 这样的工具，测量从 `Redis` 客户端到服务器端的网络延迟。


#### Redis 自身操作特性的影响

##### 慢查询命令

从慢查询命令开始排查，并且根据业务需求替换慢查询命令。

慢查询命令，就是指在 `Redis` 中执行速度慢的命令，这会导致 `Redis` `延迟增加。Redis` 提供的命令操作很多，并不是所有命令都慢，这和命令操作的复杂度有关。所以，我们必须要知道 `Redis` 的不同命令的复杂度。

当发现 `Redis` 性能变慢时，可以通过 `Redis` 日志，或者是 `latency monitor` 工具，查询变慢的请求，根据请求对应的具体命令以及官方文档，确认下是否采用了复杂度高的慢查询命令。

如果的确有大量的慢查询命令，有两种处理方式：

- 用其他高效命令代替。比如说，如果你需要返回一个 `SET` 中的所有成员时，不要使用 `SMEMBERS` 命令，而是要使用 `SSCAN` 多次迭代返回，避免一次返回大量数据，造成线程阻塞。
- 当需要执行排序、交集、并集操作时，可以在客户端完成，而不要用 `SORT`、`SUNION`、`SINTER` 这些命令，以免拖慢 `Redis` 实例。

`KEYS` 命令需要遍历存储的键值对，操作延时高，`KEYS` 命令一般不被建议用于生产环境中。

##### 过期 key 操作

排查过期 `key` 的时间设置，并根据实际使用需求，设置不同(随机数)的过期时间。

`Redis` 键值对的 `key` 可以设置过期时间。默认情况下，`Redis` 每 `100` 毫秒会删除一些过期 `key`，具体的算法如下：

- 采样 `ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP` 个数的 `key`，并将其中过期的 `key` 全部删除；
- 如果超过 `25%` 的 `key` 过期了，则重复删除的过程，直到过期 `key` 的比例降至 `25%` 以下。

`ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP` 是 `Redis` 的一个参数，默认是 `20`，那么，一秒内基本有 `200` 个过期 `key` 会被删除。这一策略对清除过期 `key`、释放内存空间很有帮助。如果每秒钟删除 `200` 个过期 `key`，并不会对 `Redis` 造成太大影响。

如果触发了上面这个算法的第二条，`Redis` 就会一直删除以释放内存空间。注意，删除操作是阻塞的（`Redis 4.0` 后可以用异步线程机制来减少阻塞影响）。所以，一旦该条件触发，`Redis` 的线程就会一直执行删除，这样一来，就没办法正常服务其他的键值操作了，就会进一步引起其他键值操作的延迟增加，`Redis` 就会变慢。

算法的第二条是怎么被触发的呢？其中一个重要来源，就是频繁使用带有相同时间参数的 `EXPIREAT` 命令设置过期 `key`，这就会导致，在同一秒内有大量的 `key` 同时过期。

#### 文件系统：AOF 模式

为了保证数据可靠性，`Redis` 会采用 `AOF` 日志或 `RDB` 快照。其中，`AOF` 日志提供了三种日志写回策略：`no`、`everysec`、`always`。这三种写回策略依赖文件系统的两个系统调用完成，也就是 `write` 和 `fsync`。

`write` 只要把日志记录写到内核缓冲区，就可以返回了，并不需要等待日志实际写回到磁盘；而 `fsync` 需要把日志记录写回到磁盘后才能返回，时间较长。下面这张表展示了三种写回策略所执行的系统调用。

![Redis写回策略所执行的系统调用](../../Picture/Redis写回策略所执行的系统调用.jpeg)

当写回策略配置为 `everysec` 时，`Redis` 会使用后台的子线程异步完成 `fsync` 的操作。`always` 策略并不使用后台子线程来执行。

`Redis` 使用子进程来进行 `AOF` 重写。
潜在的风险点：`AOF` 重写会对磁盘进行大量 `IO` 操作，同时，`fsync` 又需要等到数据写到磁盘后才能返回，所以，当 `AOF` 重写的压力比较大时，就会导致 `fsync` 被阻塞。虽然 `fsync` 是由后台子线程负责执行的，但是，主线程会监控 `fsync` 的执行进度。

当主线程使用后台子线程执行了一次 `fsync`，需要再次把新接收的操作记录写回磁盘时，如果主线程发现上一次的 `fsync` 还没有执行完，那么它就会阻塞。所以，如果后台子线程执行的 `fsync` 频繁阻塞的话（比如 `AOF` 重写占用了大量的磁盘 `IO` 带宽），主线程也会阻塞，导致 `Redis` 性能变慢。

![fsync后台子线程和主线程受到的影响](../../Picture/fsync后台子线程和主线程受到的影响.jpeg)

由于 `fsync` 后台子线程和 `AOF` 重写子进程的存在，主 `IO` 线程一般不会被阻塞。但是，如果在重写日志时，`AOF` 重写子进程的写入量比较大，`fsync` 线程也会被阻塞，进而阻塞主线程，导致延迟增加。

#### 操作系统：swap

内存 `swap` 是操作系统里将内存数据在内存和磁盘间来回换入和换出的机制，涉及到磁盘的读写，所以，一旦触发 `swap`，无论是被换入数据的进程，还是被换出数据的进程，其性能都会受到慢速磁盘读写的影响。

`Redis` 是内存数据库，内存使用量大，如果没有控制好内存的使用量，或者和其他内存需求大的应用一起运行了，就可能受到 `swap` 的影响，而导致性能变慢。

正常情况下，`Redis` 的操作是直接通过访问内存就能完成，一旦 `swap` `被触发了，Redis` 的请求操作需要等到磁盘数据读写完成才行。而且，和我刚才说的 `AOF` 日志文件读写使用 `fsync` 线程不同，`swap` 触发后影响的是 `Redis` 主 `IO` 线程，这会极大地增加 `Redis` 的响应时间。

通常，触发 `swap` 的原因主要是物理机器内存不足，对于 `Redis` 而言，有两种常见的情况：
- `Redis` 实例自身使用了大量的内存，导致物理机器的可用内存不足；
- 和 `Redis` 实例在同一台机器上运行的其他进程，在进行大量的文件读写操作。文件读写本身会占用系统内存，这会导致分配给 `Redis` 实例的内存量变少，进而触发 `Redis` 发生 `swap`。
  
解决思路：增加机器的内存或者使用 `Redis` 集群。

一旦发生内存 `swap`，最直接的解决方法就是增加机器内存。如果该实例在一个 `Redis` 切片集群中，可以增加 `Redis` 集群的实例个数，来分摊每个实例服务的数据量，进而减少每个实例所需的内存量。

#### 操作系统：内存大页

内存大页机制（`Transparent Huge Page`, `THP`），也会影响 `Redis` 性能。

`Linux` 内核从 `2.6.38` 开始支持内存大页机制，该机制支持 `2MB` 大小的内存页分配，而常规的内存页分配是按 `4KB` 的粒度来执行的。

系统的设计通常是一个取舍过程，我们称之为 `trade-off`。很多机制通常都是优势和劣势并存的。`Redis` 使用内存大页就是一个典型的例子。

虽然内存大页可以给 `Redis` 带来内存分配方面的收益，但是，不要忘了，`Redis` 为了提供数据可靠性保证，需要将数据做持久化保存。这个写入过程由额外的线程执行，所以，此时，`Redis` 主线程仍然可以接收客户端写请求。客户端的写请求可能会修改正在进行持久化的数据。在这一过程中，`Redis` 就会采用写时复制机制，也就是说，一旦有数据要被修改，`Redis` 并不会直接修改内存中的数据，而是将这些数据拷贝一份，然后再进行修改。

如果采用了内存大页，那么，即使客户端请求只修改 `100B` 的数据，`Redis` 也需要拷贝 `2MB` 的大页。相反，如果是常规内存页机制，只用拷贝 `4KB`。两者相比，你可以看到，当客户端请求修改或新写入数据较多时，内存大页机制将导致大量的拷贝，这就会影响 `Redis` 正常的访存操作，最终导致性能变慢。

解决方式：关闭内存大页。

```
首先，我们要先排查下内存大页。方法是：
在 Redis 实例运行的机器上执行如下命令:
cat /sys/kernel/mm/transparent_hugepage/enabled

如果执行结果是 always，就表明内存大页机制被启动了；如果是 never，就表示，内存大页机制被禁止。

在实际生产环境中部署时，建议不要使用内存大页机制，操作也很简单，只需要执行下面的命令就可以了：
echo never > /sys/kernel/mm/transparent_hugepage/enabled
```

#### 应对 Redis 变慢时九个检查点的 Checklist
1. 获取 `Redis` 实例在当前环境下的基线性能。
2. 是否用了慢查询命令？如果是的话，就使用其他命令替代慢查询命令，或者把聚合计算命令放在客户端做。
3. 是否对过期 `key` 设置了相同的过期时间？对于批量删除的 `key`，可以在每个 `key` 的过期时间上加一个随机数，避免同时删除。
4. 是否存在 `bigkey`？ 对于 `bigkey` 的删除操作，如果你的 `Redis` 是 `4.0` 及以上的版本，可以直接利用异步线程机制减少主线程阻塞；如果是 `Redis 4.0` 以前的版本，可以使用 `SCAN` 命令迭代删除；对于 `bigkey` 的集合查询和聚合操作，可以使用 `SCAN` 命令在客户端完成。
5. `Redis AOF` 配置级别是什么？业务层面是否的确需要这一可靠性级别？如果我们需要高性能，同时也允许数据丢失，可以将配置项 `no-appendfsync-on-rewrite` 设置为 `yes`，避免 `AOF` 重写和 `fsync` 竞争磁盘 `IO` 资源，导致 `Redis` 延迟增加。当然，如果既需要高性能又需要高可靠性，最好使用高速固态盘作为 `AOF` 日志的写入盘。
6. `Redis` 实例的内存使用是否过大？发生 `swap` 了吗？如果是的话，就增加机器内存，或者是使用 `Redis` 集群，分摊单机 `Redis` 的键值对数量和内存压力。同时，要避免出现 `Redis` 和其他内存需求大的应用共享机器的情况。
7. 在 `Redis` 实例的运行环境中，是否启用了透明大页机制？如果是的话，直接关闭内存大页机制就行了。
8. 是否运行了 `Redis` 主从集群？如果是的话，把主库实例的数据量大小控制在 `2~4GB`，以免主从复制时，从库因加载大的 `RDB` 文件而阻塞。
9. 是否使用了多核 `CPU` 或 `NUMA` 架构的机器运行 `Redis` 实例？使用多核 `CPU` 时，可以给 `Redis` 实例绑定物理核；使用 `NUMA` 架构时，注意把 `Redis` 实例和网络中断处理程序运行在同一个 `CPU Socket` 上。

```
关于如何分析、排查、解决Redis变慢问题: 
1、使用复杂度过高的命令（例如SORT/SUION/ZUNIONSTORE/KEYS），或一次查询全量数据（例如LRANGE key 0 N，但N很大）

分析：a) 查看slowlog是否存在这些命令 b) Redis进程CPU使用率是否飙升（聚合运算命令导致）

解决：a) 不使用复杂度过高的命令，或用其他方式代替实现（放在客户端做） b) 数据尽量分批查询（LRANGE key 0 N，建议N<=100，查询全量数据建议使用HSCAN/SSCAN/ZSCAN）

2、操作bigkey

分析：a) slowlog出现很多SET/DELETE变慢命令（bigkey分配内存和释放内存变慢） b) 使用redis-cli -h $host -p $port --bigkeys扫描出很多bigkey

解决：a) 优化业务，避免存储bigkey b) Redis 4.0+可开启lazy-free机制

3、大量key集中过期

分析：a) 业务使用EXPIREAT/PEXPIREAT命令 b) Redis info中的expired_keys指标短期突增

解决：a) 优化业务，过期增加随机时间，把时间打散，减轻删除过期key的压力 b) 运维层面，监控expired_keys指标，有短期突增及时报警排查

4、Redis内存达到maxmemory

分析：a) 实例内存达到maxmemory，且写入量大，淘汰key压力变大 b) Redis info中的evicted_keys指标短期突增

解决：a) 业务层面，根据情况调整淘汰策略（随机比LRU快） b) 运维层面，监控evicted_keys指标，有短期突增及时报警 c) 集群扩容，多个实例减轻淘汰key的压力

5、大量短连接请求

分析：Redis处理大量短连接请求，TCP三次握手和四次挥手也会增加耗时

解决：使用长连接操作Redis

6、生成RDB和AOF重写fork耗时严重

分析：a) Redis变慢只发生在生成RDB和AOF重写期间 b) 实例占用内存越大，fork拷贝内存页表越久 c) Redis info中latest_fork_usec耗时变长

解决：a) 实例尽量小 b) Redis尽量部署在物理机上 c) 优化备份策略（例如低峰期备份） d) 合理配置repl-backlog和slave client-output-buffer-limit，避免主从全量同步 e) 视情况考虑关闭AOF f) 监控latest_fork_usec耗时是否变长

7、AOF使用awalys机制

分析：磁盘IO负载变高

解决：a) 使用everysec机制 b) 丢失数据不敏感的业务不开启AOF

8、使用Swap

分析：a) 所有请求全部开始变慢 b) slowlog大量慢日志 c) 查看Redis进程是否使用到了Swap

解决：a) 增加机器内存 b) 集群扩容 c) Swap使用时监控报警


9、进程绑定CPU不合理

分析：a) Redis进程只绑定一个CPU逻辑核 b) NUMA架构下，网络中断处理程序和Redis进程没有绑定在同一个Socket下

解决：a) Redis进程绑定多个CPU逻辑核 b) 网络中断处理程序和Redis进程绑定在同一个Socket下

10、开启透明大页机制

分析：生成RDB和AOF重写期间，主线程处理写请求耗时变长（拷贝内存副本耗时变长）

解决：关闭透明大页机制

11、网卡负载过高

分析：a) TCP/IP层延迟变大，丢包重传变多 b) 是否存在流量过大的实例占满带宽

解决：a) 机器网络资源监控，负载过高及时报警 b) 提前规划部署策略，访问量大的实例隔离部署

```