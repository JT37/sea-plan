### Redis 变慢了

#### 如何判断 `Redis` 是不是真的变慢了

一个最直接的方法，就是查看 `Redis` 的响应延迟。

大部分时候，`Redis` 延迟很低，但是在某些时刻，有些 `Redis` 实例会出现很高的响应延迟，甚至能达到几秒到十几秒，不过持续时间不长，这也叫延迟“毛刺”。当发现 `Redis` 命令的执行时间突然就增长到了几秒，基本就可以认定 `Redis` 变慢了。

第二个方法，基于当前环境下的 `Redis` 基线性能做判断。所谓的基线性能呢，也就是一个系统在低压力、无干扰下的基本性能，这个性能只由当前的软硬件配置决定。

从 `2.8.7` 版本开始，`redis-cli` 命令提供了 `–intrinsic-latency` 选项，可以用来监测和统计测试期间内的最大延迟，这个延迟可以作为 `Redis` 的基线性能。其中，测试时长可以用 `–intrinsic-latency` 选项的参数来指定。

需要注意的是，基线性能和当前的操作系统、硬件配置相关。

一般来说，你要把运行时延迟和基线性能进行对比，如果你观察到的 `Redis` 运行时延迟是其基线性能的 `2` 倍及以上，就可以认定 `Redis` 变慢了。

如果你想了解网络对 `Redis` 性能的影响，一个简单的方法是用 · 这样的工具，测量从 `Redis` 客户端到服务器端的网络延迟。


#### Redis 自身操作特性的影响

##### 慢查询命令

从慢查询命令开始排查，并且根据业务需求替换慢查询命令。

慢查询命令，就是指在 `Redis` 中执行速度慢的命令，这会导致 `Redis` `延迟增加。Redis` 提供的命令操作很多，并不是所有命令都慢，这和命令操作的复杂度有关。所以，我们必须要知道 `Redis` 的不同命令的复杂度。

当发现 `Redis` 性能变慢时，可以通过 `Redis` 日志，或者是 `latency monitor` 工具，查询变慢的请求，根据请求对应的具体命令以及官方文档，确认下是否采用了复杂度高的慢查询命令。

如果的确有大量的慢查询命令，有两种处理方式：
- 用其他高效命令代替。比如说，如果你需要返回一个 `SET` 中的所有成员时，不要使用 `SMEMBERS` 命令，而是要使用 `SSCAN` 多次迭代返回，避免一次返回大量数据，造成线程阻塞。
- 当需要执行排序、交集、并集操作时，可以在客户端完成，而不要用 `SORT`、`SUNION`、`SINTER` 这些命令，以免拖慢 `Redis` 实例。

`KEYS` 命令需要遍历存储的键值对，操作延时高，`KEYS` 命令一般不被建议用于生产环境中。

##### 过期 key 操作

排查过期 `key` 的时间设置，并根据实际使用需求，设置不同(随机数)的过期时间。

`Redis` 键值对的 `key` 可以设置过期时间。默认情况下，`Redis` 每 `100` 毫秒会删除一些过期 `key`，具体的算法如下：
- 采样 `ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP` 个数的 `key`，并将其中过期的 `key` 全部删除；
- 如果超过 `25%` 的 `key` 过期了，则重复删除的过程，直到过期 `key` 的比例降至 `25%` 以下。

`ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP` 是 `Redis` 的一个参数，默认是 `20`，那么，一秒内基本有 `200` 个过期 `key` 会被删除。这一策略对清除过期 `key`、释放内存空间很有帮助。如果每秒钟删除 `200` 个过期 `key`，并不会对 `Redis` 造成太大影响。

如果触发了上面这个算法的第二条，`Redis` 就会一直删除以释放内存空间。注意，删除操作是阻塞的（`Redis 4.0` 后可以用异步线程机制来减少阻塞影响）。所以，一旦该条件触发，`Redis` 的线程就会一直执行删除，这样一来，就没办法正常服务其他的键值操作了，就会进一步引起其他键值操作的延迟增加，`Redis` 就会变慢。

算法的第二条是怎么被触发的呢？其中一个重要来源，就是频繁使用带有相同时间参数的 `EXPIREAT` 命令设置过期 `key`，这就会导致，在同一秒内有大量的 `key` 同时过期。

