### Redis 为什么快？
- 内存数据库，所有操作都在内存上完成，内存的访问速度本身就很快
- 数据结构，键值对是按一定的数据结构来组织的，操作键值对最终就是对数据结构进行增删改查操作，所以高效的数据结构是 `Redis` 快速处理数据的基础

### Redis 六种底层数据结构
- 简单动态字符串
- 双向链表
- 压缩列表
- 哈希表
- 整数数组
- 跳表 

![redis底层数据结构](../../Picture/redis底层数据结构.jpeg)

#### 压缩列表 (ziplist)

压缩列表实际上类似于一个数组，数组中的每一个元素都对应保存一个数据。和数组不同的是，压缩列表在表头有三个字段 `zlbytes`、`zltail` 和 `zllen`，分别表示列表长度、列表尾的偏移量和列表中的 `entry` 个数；压缩列表在表尾还有一个 `zlend`，表示列表结束。
![压缩列表的查找](../../Picture/压缩列表的查找.jpeg)
查找定位第一个元素和最后一个元素，可以通过表头三个字段的长度直接定位，复杂度是 O(1)。
查找其它元素复杂度是 O(n)

#### 跳表 (skiplist)

跳表在有序链表的基础上，增加了多级索引，通过索引位置的几个跳转，实现数据的快速定位。 类似于 二分查找。

当数据量很大时，跳表的查找复杂度就是 `O(logN)`

![跳表的快速查找过程](../../Picture/跳表的快速查找过程.jpeg)

#### 按照查找的时间复杂度给这些数据结构分下类
![数据结构按查找的时间复杂度](../../Picture/数据结构按查找的时间复杂度.jpeg)
### 键和值用什么结构组织？
- `Redis` 使用了一个哈希表来保存所有键值对
- 哈希表，可以用 `O(1)` 的时间复杂度来快速查找到键值对，只需要计算键的哈希值，就能找到哈希桶
- 一个哈希表，其实就是一个数组，数组的每个元素称为一个哈希桶
- 一个哈希表是由多个哈希桶组成的，每个哈希桶中保存了键值对数据
- 哈希桶中的元素保存的并不是值本身，而是指向具体值的指针
- 哈希桶中的 `entry` 元素中保存了 `*key` 和 `*value` 指针，分别指向了实际的键和值

![全局哈希表](../../Picture/全局哈希表.jpeg)
### 哈希冲突和 rehash 导致操作阻塞，Redis 使用渐进式哈希

#### 哈希冲突：两个不同的 `key` 哈希值一样的情况
`Redis` 解决哈希冲突的方式，就是链式哈希，是指同一个哈希桶中的多个元素用一个链表来保存，它们之间依次用指针连接。

    如下图所示：entry1、entry2 和 entry3 都需要保存在哈希桶 3 中，导致了哈希冲突。
    此时，entry1 元素会通过一个 *next 指针指向 entry2，同样，entry2 也会通过 *next 指针指向 entry3。
    这样一来，即使哈希桶 3 中的元素有 100 个，也可以通过 entry 元素中的指针，把它们连起来。这就形成了一个链表，也叫作哈希冲突链。
    这里依然存在一个问题，哈希冲突链上的元素只能通过指针逐一查找再操作。写入的数据越来越多，哈希冲突可能也会越来越多，链上的元素查找耗时长，效率降低。
![哈希表的哈希冲突](../../Picture/哈希表的哈希冲突.jpeg)

#### rehase: 再次 hash 减少哈希冲突

`rehash` 增加现有的哈希桶数量，让逐渐增多的 `entry` 元素能在更多的桶之间分散保存，减少单个桶中的元素数量，从而减少单个桶中的冲突。
为了使 rehash 操作更高效，Redis 默认使用了两个全局哈希表：哈希表 1 和哈希表 2。一开始，当你刚插入数据时，默认使用哈希表 1，此时的哈希表 2 并没有被分配空间。随着数据逐步增多，Redis 开始执行 rehash，这个过程分为三步：
- 给哈希表 2 分配更大的空间，例如是当前哈希表 1 大小的两倍；
- 把哈希表 1 中的数据重新映射并拷贝到哈希表 2 中；
- 释放哈希表 1 的空间。

这里有一个问题，第二步涉及大量的数据拷贝，如果一次性把哈希表 1 中的数据都迁移完，会造成 Redis 线程阻塞，无法服务其他请求。此时，Redis 就无法快速访问数据了。

#### redis 使用渐进式 rehash

简单来说就是在第二步拷贝数据时，`Redis` 仍然正常处理客户端请求，每处理一个请求时，从哈希表 1 中的第一个索引位置开始，顺带着将这个索引位置上的所有 `entries` 拷贝到哈希表 2 中；等处理下一个请求时，再顺带拷贝哈希表 1 中的下一个索引位置的 `entries`。如下图所示：

![渐进式rehash](../../Picture/渐进式rehash.jpeg)


### Redis 对集合类型不同操作的复杂度

#### 单元素操作是基础
- 单元素操作，是指每一种集合类型对单个数据实现的增删改查操作
- 复杂度由集合采用的数据结构决定
- `HGET`、`HSET` 和 `HDEL` 是对哈希表做操作，所以复杂度都是 `O(1)`
- `Set` 类型用哈希表作为底层数据结构时，它的 `SADD`、`SREM`、`SRANDMEMBER` 复杂度也是 `O(1)`
- `HMSET` 增加 `M` 个元素时，复杂度就从 `O(1)` 变成 `O(M)`

#### 范围操作非常耗时
- 范围操作，是指集合类型中的遍历操作，可以返回集合中的所有数据，比如 `HGETALL``、SMEMBERS`。返回范围数据，比如 `LRANGE`、`ZRANGE`
-  复杂度一般是 `O(N)` 
- 渐进式遍历，`SCAN` 系列操作（包括 `HSCAN`，`SSCAN` 和 `ZSCAN`），避免了一次性返回所有元素而导致的 `Redis` 阻塞

#### 统计操作通常高效
- 统计操作，是指集合类型对集合中所有元素个数的记录，例如 `LLEN` 和 `SCARD`，复杂度只有 `O(1)`
- 当集合类型采用压缩列表、双向链表、整数数组这些数据结构时，这些结构中专门记录了元素的个数统计，因此可以高效地完成相关操作

#### 例外情况只有几个
- 例外情况，是指某些数据结构的特殊记录
- 压缩列表和双向链表都会记录表头和表尾的偏移量
- 对于 `List` 类型的 `LPOP`、`RPOP`、`LPUSH`、`RPUSH` 这四个操作来说，它们是在列表的头尾增删元素，这就可以通过偏移量直接定位，所以它们的复杂度也只有 `O(1)`，可以实现快速操作