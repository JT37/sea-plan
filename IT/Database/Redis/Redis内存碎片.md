#### 什么是内存碎片？

删除数据后，内存占用率还是很高的主因：内存碎片。

通常情况下，内存空间闲置，往往是因为操作系统发生了较为严重的内存碎片。

![redis内存碎片](../../Picture/redis内存碎片.jpeg)
虽然操作系统的剩余内存空间总量足够，但是，应用申请的是一块连续地址空间的 `N` 字节，但在剩余的内存空间中，没有大小为 `N` 字节的连续空间了，那么，这些剩余空间就是内存碎片（比如上图中的“空闲 `2` 字节”和“空闲 `1` 字节”，就是这样的碎片）。

#### 内存碎片是如何形成的？

内存碎片的形成有内因和外因两个层面的原因。简单来说，内因是操作系统的内存分配机制，外因是 `Redis` 的负载特征。

##### 内因：内存分配器的分配策略

内存分配器的分配策略就决定了操作系统无法做到“按需分配”。这是因为，内存分配器一般是按固定大小来分配内存，而不是完全按照应用程序申请的内存空间大小给程序分配。

`Redis` 可以使用 `libc`、`jemalloc`、`tcmalloc` 多种内存分配器来分配内存，默认使用 `jemalloc`。

`jemalloc` 的分配策略之一，是按照一系列固定的大小划分内存空间，例如 `8 字节、16 字节、32 字节、48 字节，…, 2KB、4KB、8KB` 等。当程序申请的内存最接近某个固定值时，`jemalloc` 会给它分配相应大小的空间。

这样的分配方式本身是为了减少分配次数。例如，`Redis` 申请一个 `20` 字节的空间保存数据，`jemalloc` 就会分配 `32` 字节，此时，如果应用还要写入 `10` 字节的数据，`Redis` 就不用再向操作系统申请空间了，因为刚才分配的 `32` 字节已经够用了，这就避免了一次分配操作。

如果 `Redis` 每次向分配器申请的内存空间大小不一样，这种分配方式就会有形成碎片的风险，而这正好来源于 `Redis` 的外因了。

##### 外因：键值对大小不一样和删改操作

`Redis` 通常作为共用的缓存系统或键值数据库对外提供服务，所以，不同业务应用的数据都可能保存在 `Redis` 中，这就会带来不同大小的键值对。这样一来，`Redis` 申请内存空间分配时，本身就会有大小不一的空间需求。这是第一个外因。

内存分配器只能按固定大小分配内存，所以，分配的内存空间一般都会比申请的空间大一些，不会完全一致，这本身就会造成一定的碎片，降低内存空间存储效率。


#### 如何判断是否有内存碎片？

`Redis` 是内存数据库，内存利用率的高低直接关系到 `Redis` 运行效率的高低。为了让用户能监控到实时的内存使用情况，`Redis` 自身提供了 `INFO` 命令，可以用来查询内存使用的详细信息，命令如下：
```

INFO memory
# Memory
used_memory:1073741736
used_memory_human:1024.00M
used_memory_rss:1997159792
used_memory_rss_human:1.86G
…
mem_fragmentation_ratio:1.86

这里有一个 mem_fragmentation_ratio 的指标，它表示的就是 Redis 当前的内存碎片率。是上面的命令中的两个指标 used_memory_rss 和 used_memory 相除的结果。mem_fragmentation_ratio = used_memory_rss/ used_memory

used_memory_rss 是操作系统实际分配给 Redis 的物理内存空间，里面就包含了碎片；而 used_memory 是 Redis 为了保存数据实际申请使用的空间。

Redis 申请使用了 100 字节（used_memory），操作系统实际分配了 128 字节（used_memory_rss），此时，mem_fragmentation_ratio 就是 1.28。

mem_fragmentation_ratio 大于 1 但小于 1.5。这种情况是合理的。这是因为，刚才我介绍的那些因素是难以避免的。毕竟，内因的内存分配器是一定要使用的，分配策略都是通用的，不会轻易修改；而外因由 Redis 负载决定，也无法限制。所以，存在内存碎片也是正常的。

mem_fragmentation_ratio 大于 1.5 。这表明内存碎片率已经超过了 50%。一般情况下，这个时候，我们就需要采取一些措施来降低内存碎片率了。
```

#### 如何清理内存碎片？

当 `Redis` 发生内存碎片后，一个“简单粗暴”的方法就是重启 `Redis` 实例。当然，这并不是一个“优雅”的方法，毕竟，重启 `Redis` 会带来两个后果：
- 如果 `Redis` 中的数据没有持久化，那么，数据就会丢失；
- 即使 `Redis` 数据持久化了，我们还需要通过 `AOF` 或 `RDB` 进行恢复，恢复时长取决于 `AOF` 或 `RDB` 的大小，如果只有一个 Redis 实例，恢复阶段无法提供服务。

从 `4.0-RC3` 版本以后，`Redis` 自身提供了一种内存碎片自动清理的方法，来看这个方法的基本机制。

内存碎片清理，简单来说，就是“搬家让位，合并空间”。

![Redis内存碎片自动清理](../../Picture/Redis内存碎片自动清理.jpeg)

碎片清理是有代价的，操作系统需要把多份数据拷贝到新位置，把原有空间释放出来，这会带来时间开销。因为 `Redis` 是单线程，在数据拷贝时，`Redis` 只能等着，这就导致 `Redis` 无法及时处理请求，性能就会降低。

`Redis` 专门为自动内存碎片清理功机制设置的参数了。我们可以通过设置参数，来控制碎片清理的开始和结束时机，以及占用的 `CPU` 比例，从而减少碎片清理对 `Redis` 本身请求处理的性能影响。

`Redis` 需要启用自动内存碎片清理，可以把 `activedefrag` 配置项设置为 `yes` 。`config set activedefrag yes` 只是用了自动清理功能，但是，具体什么时候清理，会受到下面这两个参数的控制。这两个参数分别设置了触发内存清理的一个条件，如果同时满足这两个条件，就开始清理。在清理的过程中，只要有一个条件不满足了，就停止自动清理。

- `active-defrag-ignore-bytes 100mb`：表示内存碎片的字节数达到 `100MB` 时，开始清理；
- `active-defrag-threshold-lower 10`：表示内存碎片空间占操作系统分配给 `Redis` 的总空间比例达到 `10%` 时，开始清理。

为了尽可能减少碎片清理对 `Redis` 正常请求处理的影响，自动内存碎片清理功能在执行时，还会监控清理操作占用的 `CPU` 时间，而且还设置了两个参数，分别用于控制清理操作占用的 `CPU` 时间比例的上、下限，既保证清理工作能正常进行，又避免了降低 `Redis` 性能。这两个参数具体如下：
- `active-defrag-cycle-min 25`： 表示自动清理过程所用 `CPU` 时间的比例不低于 `25%`，保证清理能正常开展；
- `active-defrag-cycle-max 75`：表示自动清理过程所用 `CPU` 时间的比例不高于 `75%`，一旦超过，就停止清理，从而避免在清理时，大量的内存拷贝阻塞 `Redis`，导致响应延迟升高。

自动内存碎片清理机制在控制碎片清理启停的时机上，既考虑了碎片的空间占比、对 `Redis` 内存使用效率的影响，还考虑了清理机制本身的 `CPU` 时间占比、对 `Redis` 性能的影响。


#### Redis 的内存空间效率问题，简单来说，就是“三个一”：

- `info` `memory` 命令是一个好工具，可以帮助你查看碎片率的情况；
- 碎片率阈值是一个好经验，可以帮忙你有效地判断是否要进行碎片清理了；
- 内存碎片自动清理是一个好方法，可以避免因为碎片导致 `Redis` 的内存实际利用率降低，提升成本收益率。