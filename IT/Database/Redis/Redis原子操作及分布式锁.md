### 原子操作

为了保证并发访问的正确性，`Redis` 提供了两种方法，分别是加锁和原子操作。

加锁是一种常用的方法，在读取数据前，客户端需要先获得锁，否则就无法进行操作。当一个客户端获得锁后，就会一直持有这把锁，直到客户端完成数据更新，才释放这把锁。

加锁会有两个问题：一个是，如果加锁操作多，会降低系统的并发访问性能；第二个是，`Redis` 客户端要加锁时，需要用到分布式锁，而分布式锁实现复杂，需要用额外的存储系统来提供加解锁操作。

原子操作是指执行过程保持原子性的操作，而且原子操作执行时并不需要再加锁，实现了无锁操作。这样一来，既能保证并发控制，还能减少对系统并发性能的影响。

当客户端需要修改数据时，基本流程分成两步：
- 客户端先把数据读取到本地，在本地进行修改；
- 客户端修改完数据后，再写回 Redis。
这个流程叫做 `读取 - 修改 - 写回` 操作 `Read-Modify-Write`，简称为 `RMW` 操作。

当有多个客户端对同一份数据执行 `RMW` 操作的话，我们就需要让 `RMW` 操作涉及的代码以原子性方式执行。访问同一份数据的 `RMW` 操作代码，就叫做临界区代码。

#### Redis 的两种原子操作方法
- 把多个操作在 `Redis` 中实现成一个操作，也就是单命令操作；
- 把多个操作写到一个 `Lua` 脚本中，以原子性方式执行单个 `Lua` 脚本。

`Redis` 提供了 `INCR/DECR` 命令，把这三个操作转变为一个原子操作了。`INCR/DECR` 命令可以对数据进行增值 / 减值操作，而且它们本身就是单个命令操作，`Redis` 在执行它们时，本身就具有互斥性。

使用 Lua 脚本来保证并发控制，将多个命令放在脚本里执行，如下事例：
```
// 如果incr后判断是 1，设置过期时间
local current
current = redis.call("incr",KEYS[1])
if tonumber(current) == 1 then
    redis.call("expire",KEYS[1],60)
end

// 使用 Redis 客户端，带上 eval 选项，来执行该脚本
redis-cli  --eval lua.script  keys , args
```

注：在编写 `Lua` 脚本时，要避免把不需要做并发控制的操作写入脚本中。


### 分布式锁