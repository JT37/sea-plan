### 原子操作

为了保证并发访问的正确性，`Redis` 提供了两种方法，分别是加锁和原子操作。

加锁是一种常用的方法，在读取数据前，客户端需要先获得锁，否则就无法进行操作。当一个客户端获得锁后，就会一直持有这把锁，直到客户端完成数据更新，才释放这把锁。

加锁会有两个问题：一个是，如果加锁操作多，会降低系统的并发访问性能；第二个是，`Redis` 客户端要加锁时，需要用到分布式锁，而分布式锁实现复杂，需要用额外的存储系统来提供加解锁操作。

原子操作是指执行过程保持原子性的操作，而且原子操作执行时并不需要再加锁，实现了无锁操作。这样一来，既能保证并发控制，还能减少对系统并发性能的影响。

当客户端需要修改数据时，基本流程分成两步：
- 客户端先把数据读取到本地，在本地进行修改；
- 客户端修改完数据后，再写回 Redis。
这个流程叫做 `读取 - 修改 - 写回` 操作 `Read-Modify-Write`，简称为 `RMW` 操作。

当有多个客户端对同一份数据执行 `RMW` 操作的话，我们就需要让 `RMW` 操作涉及的代码以原子性方式执行。访问同一份数据的 `RMW` 操作代码，就叫做临界区代码。

#### Redis 的两种原子操作方法
- 把多个操作在 `Redis` 中实现成一个操作，也就是单命令操作；
- 把多个操作写到一个 `Lua` 脚本中，以原子性方式执行单个 `Lua` 脚本。

`Redis` 提供了 `INCR/DECR` 命令，把这三个操作转变为一个原子操作了。`INCR/DECR` 命令可以对数据进行增值 / 减值操作，而且它们本身就是单个命令操作，`Redis` 在执行它们时，本身就具有互斥性。

使用 Lua 脚本来保证并发控制，将多个命令放在脚本里执行，如下事例：
```
// 如果incr后判断是 1，设置过期时间
local current
current = redis.call("incr",KEYS[1])
if tonumber(current) == 1 then
    redis.call("expire",KEYS[1],60)
end

// 使用 Redis 客户端，带上 eval 选项，来执行该脚本
redis-cli  --eval lua.script  keys , args
```

注：在编写 `Lua` 脚本时，要避免把不需要做并发控制的操作写入脚本中。


### 分布式锁

分布式锁是由共享存储系统维护的变量，多个客户端可以向共享存储系统发送命令进行加锁或释放锁操作。`Redis` 作为一个共享存储系统，可以用来实现分布式锁。

#### 单机上的锁和分布式锁的联系与区别

对于在单机上运行的多线程程序来说，锁本身可以用一个变量表示。
- 变量值为 `0` 时，表示没有线程获取锁；
- 变量值为 `1` 时，表示已经有线程获取到锁了。

实现分布式锁的两个要求:
- 要求一：分布式锁的加锁和释放锁的过程，涉及多个操作。所以，在实现分布式锁时，我们需要保证这些锁操作的原子性；
- 要求二：共享存储系统保存了锁变量，如果共享存储系统发生故障或宕机，那么客户端也就无法进行锁操作了。在实现分布式锁时，我们需要考虑保证共享存储系统的可靠性，进而保证锁的可靠性。

#### 基于单个 Redis 节点实现分布式锁

使用 `SET` 命令和 `Lua` 脚本在 `Redis` 单节点上实现分布式锁。
```

// 加锁, unique_value作为客户端唯一性的标识
SET lock_key unique_value NX PX 10000


// Lua 脚本释放锁 比较unique_value是否相等，避免误释放
// 用 Lua 脚本（unlock.script）实现的释放锁操作的伪代码，其中，KEYS[1]表示 lock_key，ARGV[1]是当前客户端的唯一标识，这两个值都是我们在执行 Lua 脚本时作为参数传入的。
if redis.call("get",KEYS[1]) == ARGV[1] then
    return redis.call("del",KEYS[1])
else
    return 0
end

redis-cli  --eval  unlock.script lock_key , unique_value 
```

在释放锁操作中，我们使用了 `Lua` 脚本，这是因为，释放锁操作的逻辑也包含了读取锁变量、判断值、删除锁变量的多个操作，而 `Redis` 在执行 `Lua` 脚本时，可以以原子性的方式执行，从而保证了锁释放操作的原子性。

#### 基于多个 Redis 节点实现高可靠的分布式锁

为了保证分布式锁的可靠性，基于多个 `Redis` 节点实现分布式锁。

为了避免 `Redis` 实例故障而导致的锁无法工作的问题，`Redis` 的开发者 `Antirez` 提出了分布式锁算法 `Redlock`。

`Redlock` 算法的基本思路，是让客户端和多个独立的 `Redis` 实例依次请求加锁，如果客户端能够和半数以上的实例成功地完成加锁操作，那么我们就认为，客户端成功地获得分布式锁了，否则加锁失败。这样一来，即使有单个 `Redis` 实例发生故障，因为锁变量在其它实例上也有保存，所以，客户端仍然可以正常地进行锁操作，锁变量并不会丢失。

#### Redlock 算法的执行步骤
- 第一步是，客户端获取当前时间。
- 第二步是，客户端按顺序依次向 `N` 个 `Redis` 实例执行加锁操作。
  - 这里的加锁操作和在单实例上执行的加锁操作一样，使用 `SET` 命令，带上 `NX`，`EX/PX` 选项，以及带上客户端的唯一标识。当然，如果某个 `Redis` 实例发生故障了，为了保证在这种情况下，`Redlock` 算法能够继续运行，需要给加锁操作设置一个超时时间。

  - 如果客户端在和一个 `Redis` 实例请求加锁时，一直到超时都没有成功，那么此时，客户端会和下一个 `Redis` 实例继续请求加锁。加锁操作的超时时间需要远远地小于锁的有效时间，一般也就是设置为几十毫秒。

- 第三步是，一旦客户端完成了和所有 `Redis` 实例的加锁操作，客户端就要计算整个加锁过程的总耗时。客户端只有在满足下面的这两个条件时，才能认为是加锁成功。
  - 条件一：客户端从超过半数（大于等于 `N/2+1`）的 `Redis` 实例上成功获取到了锁；
  - 条件二：客户端获取锁的总耗时没有超过锁的有效时间。

在满足了这两个条件后，需要重新计算这把锁的有效时间，计算的结果是锁的最初有效时间减去客户端为获取锁的总耗时。如果锁的有效时间已经来不及完成共享数据的操作了，我们可以释放锁，以免出现还没完成数据操作，锁就过期了的情况。

如果客户端在和所有实例执行完加锁操作后，没能同时满足这两个条件，那么，客户端向所有 `Redis` 节点发起释放锁的操作。

在 `Redlock` 算法中，释放锁的操作和在单实例上释放锁的操作一样，只要执行释放锁的 `Lua` 脚本就可以了。这样一来，只要 `N` 个 `Redis` 实例中的半数以上实例能正常工作，就能保证分布式锁的正常工作了。


#### 基于 Redis 使用分布锁的注意点：
- 使用 `SET $lock_key $unique_val EX $second NX` 命令保证加锁原子性，并为锁设置过期时间
- 锁的过期时间要提前评估好，要大于操作共享资源的时间
- 每个线程加锁时设置随机值，释放锁时判断是否和加锁设置的值一致，防止自己的锁被别人释放
- 释放锁时使用 `Lua` 脚本，保证操作的原子性
- 基于多个节点的 `Redlock`，加锁时超过半数节点操作成功，并且获取锁的耗时没有超过锁的有效时间才算加锁成功
- `Redlock` 释放锁时，要对所有节点释放（即使某个节点加锁失败了），因为加锁时可能发生服务端加锁成功，由于网络问题，给客户端回复网络包失败的情况，所以需要把所有节点可能存的锁都释放掉
- 使用 `Redlock` 时要避免机器时钟发生跳跃，需要运维来保证，对运维有一定要求，否则可能会导致 `Redlock` 失效。例如共 `3` 个节点，线程 `A` 操作 `2` 个节点加锁成功，但其中 `1` 个节点机器时钟发生跳跃，锁提前过期，线程 `B` 正好在另外 `2` 个节点也加锁成功，此时 `Redlock` 相当于失效了（`Redis` 作者和分布式系统专家争论的重要点就在这）
- 如果为了效率，使用基于单个 `Redis` 节点的分布式锁即可，此方案缺点是允许锁偶尔失效，优点是简单效率高
- 如果是为了正确性，业务对于结果要求非常严格，建议使用 `Redlock`，但缺点是使用比较重，部署成本高
