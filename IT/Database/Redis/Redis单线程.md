### Redis 单线程？

 `Redis` 是单线程，主要是指 `Redis` 的网络 `IO` 和键值对读写是由一个线程来完成的，这也是 `Redis` 对外提供键值存储服务的主要流程。但 `Redis` 的其他功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程执行的。
 严格来说，不是单线程

 ### Redis 为什么用单线程？

主要是因为多线程的开销：

- 增加线程数时，系统吞吐率会增加，但是，再进一步增加线程时，系统吞吐率就增长迟缓了，有时甚至还会出现下降的情况。

- 一个关键的瓶颈在于，系统中通常会存在被多线程同时访问的共享资源，比如一个共享的数据结构。当有多个线程要修改这个共享资源时，为了保证共享资源的正确性，就需要有额外的机制(互斥锁、同步原语)进行保证，而这个额外的机制，就会带来额外的开销。

- 多线程编程模式会面临共享资源的并发访问控制问题。

### 单线程 Redis 为什么那么快？

- 内存数据库，所有操作都在内存上完成，内存的访问速度本身就很快
- 数据结构，键值对是按一定的数据结构来组织的，操作键值对最终就是对数据结构进行增删改查操作，所以高效的数据结构是 `Redis` 快速处理数据的基础
- 采用了多路复用机制，使其在网络 `IO` 操作中能并发处理大量的客户端请求，实现高吞吐率

#### 基本 IO 模型与阻塞点

`bind/listen`、`accept`、`recv`、`parse` 和 `send` 属于网络 `IO` 处理，而 `get` 属于键值数据操作
![redis的基本IO模型](../../Picture/redis的基本IO模型.jpeg)

当 `Redis` 监听到一个客户端有连接请求，但一直未能成功建立起连接时，会阻塞在 `accept()` 函数这里，导致其他客户端无法和 `Redis` 建立连接。类似的，当 `Redis` 通过 `recv()` 从一个客户端读取数据时，如果数据一直没有到达，`Redis` 也会一直阻塞在 `recv()`。

这就导致 `Redis` 整个线程阻塞，无法处理其他客户端请求，效率很低。不过，`socket` 网络模型本身支持非阻塞模式。

#### 非阻塞模式
