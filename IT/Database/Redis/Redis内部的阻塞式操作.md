### Redis 实例有哪些阻塞点？
Redis 实例在运行时，要和许多对象进行交互，这些不同的交互就会涉及不同的操作。
- 客户端：网络 `IO`，键值对增删改查操作，数据库操作；
- 磁盘：生成 `RDB` 快照，记录 `AOF` 日志，`AOF` 日志重写；
- 主从节点：主库生成、传输 `RDB` 文件，从库接收 `RDB` 文件、清空数据库、加载 `RDB` 文件；
- 切片集群实例：向其他实例传输哈希槽信息，数据迁移。

![Redis阻塞点示意图](../../Picture/Redis阻塞点示意图.jpeg)

#### 客户端阻塞点

##### 第一个阻塞点：集合全量查询和聚合操作
`Redis` 使用了 `IO` 多路复用机制，避免了主线程一直处在等待网络连接或请求到来的状态，所以，网络 `IO` 不是导致 `Redis` 阻塞的因素。

键值对的增删改查操作是 `Redis` 和客户端交互的主要部分，也是 `Redis` 主线程执行的主要任务。所以，复杂度高的增删改查操作肯定会阻塞 `Redis`。

看操作的复杂度是否为 `O(N)`，是判断操作复杂度的最基本标准。

`Redis` 中涉及集合的操作复杂度通常为 `O(N)`，例如集合元素全量查询操作 `HGETALL`、`SMEMBERS`，以及集合的聚合统计操作，例如求交、并和差集。这些操作可以作为 `Redis` 的 第一个阻塞点。

##### 第二个阻塞点：bigkey 删除操作
删除操作的本质是要释放键值对占用的内存空间。

释放内存只是第一步，为了更加高效地管理内存空间，在应用程序释放内存时，操作系统需要把释放掉的内存块插入一个空闲内存块的链表，以便后续进行管理和再分配。这个过程本身需要一定时间，而且会阻塞当前释放内存的应用程序，所以，如果一下子释放了大量内存，空闲内存块链表操作时间就会增加，相应地就会造成 `Redis` 主线程的阻塞。

在删除大量键值对数据的时候，最典型的就是删除包含了大量元素的集合，也称为 `bigkey` 删除。

![Redis不同集合类型bigkey删除时间](../../Picture/Redis不同集合类型bigkey删除时间.jpeg)

如图显而易见，删除操作对 `Redis` 实例性能的负面影响很大，业务开发一定要重视。

##### 第三个阻塞点：清空数据库

频繁删除键值对都是潜在的阻塞点了，那么，在 `Redis` 的数据库级别操作中，清空数据库（例如 `FLUSHDB` 和 `FLUSHALL` 操作）必然也是一个潜在的阻塞风险，因为它涉及到删除和释放所有的键值对。

扩展：
`Redis Flushall` 命令用于清空整个 `Redis` 服务器的数据(删除所有数据库的所有 `key` )。

`Redis Flushdb` 命令用于清空当前数据库中的所有 `key`。


